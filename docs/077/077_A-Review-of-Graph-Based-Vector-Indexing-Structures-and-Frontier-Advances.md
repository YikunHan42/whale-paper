# 基于图索引的高维向量搜索回顾与新进展

## 背景

应用场景

+ 商品推荐
+ 以图搜图
+ 科学研究（蛋白质结构预测）



ChatGPT的一些缺陷

+ 需要精确专业知识的问题
+ 如：提供领域相关论文、对时间复杂度提供分析
+ 通过ChatGPT Retrieval Plugin解决（专业引用 -> 可信AI，语料库文本与query之间相似度的查询）



ChatGPT Retrieval Plugin工作逻辑

语料库 -> OpenAI embedding -> 向量数据库 -> 核心数据结构 -> 近邻图索引

## 回顾近邻图索引的设计原则与查询方案

### 近邻图索引的设计原则

问题定义：在大量等长向量中找出距离给定向量最近的top-K个向量，距离一般为欧氏距离。

设计原则：

1. 导航特性(small-world phenomenon)
   1. 边的长度服从指数分布
   2. 长边负责快速导航
   3. 短边负责高精度检索
2. 裁边策略（边的多样性）
   1. 保留多方向的邻居



### 近邻图索引的查询方式

+ Best First Search: 从某一/几个入口点开始，探测每一个邻居，维护探测过的所有点的距离（保存在优先级队列中），每次选择与query最近的点继续路由。
+ 注意：并非一定是沿着单方向的路线靠近query。若不慎走偏，可以从新的方向继续路由搜索。
+ 限制优先级队列长度，直到队列中没有能提供更近距离的点了，算法终止。（local optimum，局部最优解）



### 近邻图索引的设计思路

+ 边并非越多越好 -> O(Mpd)查询的每一步
  + M：最大邻居个数
  + p：搜索路径长度
  + d：向量维数
+ 设计思路：从性质良好的基本几何图入手
  + Voroni Diagram（与聚类算法相似，把图上的每一点当作一个聚类中心来看待，图上的每一边都是两点连线的垂直平分线）
  + Delaunay Graph(RNG pruning rule，将靠近同方向的邻近边裁去)



### 近邻图索引的构建方法

NSW：越早生成长边 越晚生成短边

HNSW：hub节点层次化，RNG剪枝与反向边补充 -> 随机分层，各层向量基数呈指数分布，逐层查询



### 对HNSW的进一步思考

1. 层次化的必要性
   + flat-HNSW：仅搜索HNSW的最底层
   + “实验主义”的结论：层次化必要性不大，前期导航的速度已经足够快
   + HNSW边的访问频率存在“二八定律” -> 仍然存有hub节点
2. 裁边规则的多样性
   + KGraph: KNN-graph
   + KGraph+GD: KNN-graph+Graph Diversification(反向边补充+RNG裁边)
   + ”实验主义“的结论：裁边规则对性能提升影响很大
   + 进一步补充反向边的设计方案可以得到小幅性能提升
3. 图结构的唯一性
   + 改变索引插入顺序，同一个query的“难度”变化巨大，但一组query集的平均性能稳定
   + 查询长尾分布 & learning-based optimization
4. 查询/插入复杂度问题
   + O(logn)的前置条件：精确delaunay图
   + 推导要素：共O(logn)层，每层搜索复杂度为常量
   + 实验模拟：>10m的数据集吻合程度不佳

## 前沿近邻图索引解决方案介绍：HVS

### 动机

+ 在图索引的搜索路径中，路径长度和每跳距离计算次数共同构成搜索的时间开销
+ 在搜索的早期阶段，精确计算与每个邻居的距离是不必要的
+ 1. 可通过由粗到细的层次化空间分割，将query point**快速路由**到结果附近的区域当中
  2. 在此区域利用图索引找出高精度KNN
+ 取代HNSW上面若干层的作用



### 乘积量化（PQ）的简单回顾

将原始向量分段后，在每一段上做k-means聚类，然后规约到最近的向量中心，对聚类中心编码，最终得到码本



+ 原始向量：（1.1, 2.2, 3.1, 4.1, 5.1, 6.7)
+ 分段向量：（[1.1, 2.2], [3.1, 4.1], [5.1, 6.7])
+ 近似向量：（[1.0, 1.9], [3.0, 4.6], [5.4, 7.2])
+ 编码向量：（11,10,00)



### 乘积量化（PQ）的基本分析

每一段L种编码，m段可产生$L^m$种不同编码 <=> 在高维向量中找到了$L^m$个聚类中心

每一段产生一个子码书

每个子码书里有L个子码字



压缩前每条向量占用空间：n\*d\*sizeof(float) bytes

压缩后每条向量占用空间：m\*log(L) bits



### 多级乘积量化算法

+ 目的：构建均匀的空间分区
  + “等宽“量化 => ”等深量化“
+ 核心思路：自底向上构建分区，首先在最底层构建充分稠密的Voronoi图，逐渐向上抽取聚类中心
+ 具体方法：如固定每个子码字的个数L为2，从1到T层的分段数为(2,4,8,...$2^T$) => 聚类中心个数为($2^2$, $2^4$,$2^8$,...,$2^{2^T}$)
+ 特点1：分区密度指数递增（自上而下）
+ 问题：如何基于底层的稠密分区构造上层的稀疏分区？
+ 想法
  1. 最好从已有的聚类中心中选择，可以简化构建和查询时的距离计算
  2. 已有的聚类中心由多个sub-codebooks构成，在固定L的情况下，可以两两匹配分段及其对应的sub-codebook
  3. 每一对sub-codebook都会产生$L^2$个sub-codewords，则我们需要从中选出L个”合适“的sub-codewords



### 基于密度的数据分配策略

+ 目的：在层次化分区的空间中放置数据，解决数据分布倾斜问题
+ 核心思路：自上而下分配数据点，顶层包含所有数据，下层数据是上层数据的子集
+ 在上层的分区中，处于过于”稠密“的区域中的点会被选中，继续放置入下层以细粒度区分
+ 稠密度判定



### 整体结构

+ 整体分为两部分：前一部分为HVS，后一部分为HNSW
+ 代表点：每个Voronoi cell中和seed point最近的数据点
+ 层内连接：除第一层外，每一层的有效seed point会建立HNSW
+ 跨层连接
  1. 如果当前cell中的所有点都中止了，则此cell直接连向base layer中的代表点
  2. 否则找到距离seed point最近的未中止的点，则此cell连向下一层包含该点的cell的seed point
  3. top layer的点直接在second layer中寻找k0 NN连接



### 查询方法

1. 通过PQ的码书找到top layer精确top1
2. 此后通过跨层边到达second layer, 在层内做标准贪心搜索，找到一批seed point和对应的Voronoi cells
3. 如仍未中止则钻入下层搜索，否则就找到了base layer的一个入口点



## 树图结合的索引方案综述

### SPANN

+ 背景：大规模磁盘向量索引问题
+ 核心思路：通过平衡K-means树对数据进行聚类，在内存对聚类中心建图，加速定位邻近聚类
+ 结果：磁盘索引性能优于DiskANN(SOTA)



### Elpis

+ 背景：大规模内存向量索引问题
+ 基本方法：基于SOTA时序索引树Hercules做初步数据分区，在每个叶子节点在建立HNSW图索引
+ 结果：构建开销与内存开销显著降低，1B数据集上性能有明显提升

## 现有问题与未来展望

+ 更清晰的机理分析和性能优化设计
  + 图索引的作用机理尚不明晰，设计上的考量多为启发式，缺少形式化验证对查询的保障，时间复杂度问题尚未解决
  + 树图结合式索引已初步体现出优势，一个可能的思路是：远距离导航由空间分割树或PQ负责，而将图索引改造为专为局部邻近区域提供高精度检索
+ 更丰富的应用场景
  + 多模态场景：异构分布的数据集
  + 在线场景：高效动态插入和删除
  + 混合查询：标量向量混合、多向量查询